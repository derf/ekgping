#!/usr/bin/env perl

use strict;
use warnings;
use 5.010;

use IO::Handle;
use IPC::Run qw(harness io);
use SDL::Mixer;
use SDL::Music;
use Term::Size;
use Time::HiRes qw(usleep);

our $VERSION = '0.0';

my $host    = shift;
my $id      = 0;
my $rtt     = 0;
my $last_id = 0;
my $beep;
my $was_beep   = 1;
my $dead_count = 0;
my $column     = 0;
my $column_max = Term::Size::chars;

my $mixer      = SDL::Mixer->new();
my $beep_sound = SDL::Music->new('beep.ogg');

my $ping = harness(
	[ 'ping', '-n', $host ],
	'<'  => \undef,
	'>&' => \&parse_ping_output,
);

local $SIG{TERM} = \&quit;
local $SIG{INT}  = \&quit;

sub parse_ping_output {
	my ($line) = @_;

	chomp($line);

	if (
		$line =~ m{ ^ \d+ \s bytes \s from \s \S+ \s
			icmp_req = (?<id> \d+ ) \s
			ttl = (?<ttl> \d+ ) \s
			time = (?<time> [0-9.]+) \s ms }x
	  )
	{
		$id  = $+{id};
		$rtt = $+{time};
	}

	return;
}

sub quit {
	$ping->kill_kill( grace => 1 );
	print "\e[?25h";
	exit 0;
}

$ping->start();

# Ignore first line
$ping->pump();

$mixer->play_music( $beep_sound, 999_999 );
$mixer->pause_music();

print "\e[?25l";

while ( usleep(100_000) ) {

	$ping->pump_nb();

	$column++;

	if ( $column == $column_max ) {
		print "\r";
		$column = 0;
	}

	if ( $column != $column_max ) {
		print "\e[1C \e[2D";
	}

	if ( $id != $last_id ) {
		$beep = 1;
		if ( $rtt < 300 ) {
			print q{^};
		}
		else {
			print q{-};
		}
		$last_id    = $id;
		$dead_count = 0;
	}
	else {
		$beep = 0;
		$dead_count++;
		if ( $dead_count > 30 ) {
			$beep = 1;
		}

		print q{_};
	}

	STDOUT->flush();

	if ($beep) {
		$mixer->resume_music();
	}
	else {
		$mixer->pause_music();
	}
}

$ping->kill_kill( grace => 1 );

__END__

=head1 NAME

B<ekgping> - Electrocardiograph-like visual and audible ping

=head1 SYNOPSIS

B<ekgping> I<host>

=head1 VERSION

version 0.0

=head1 DESCRIPTION

B<ekgping> pings a I<host>. Unlike ping(1), it does not output text, but
instead displays the results in a visual and audible manner, somewhat similar
to an electrocardiograph (short ECG / EKG).

It displays a line on the whole width of the terminal. By default, the line is
flat ("_"). Everytime a pong gets in, a spike ("^" or "-", depending on RTT)
is drawn.

Also, everytime a pong is received, a short beep is played. If the host does
not respond for a few seconds (i.e. is unreachable/dead), B<ekgping> produces
a continuous beep until the host is reachable again.

=head1 OPTIONS

None.

=head1 EXIT STATUS

Zero.

=head1 CONFIGURATION

None.

=head1 DEPENDENCIES

=over

=item * IPC::Run(3pm)

=item * SDL::Mixer(3pm)

=item * SDL::Music(3pm)

=item * Term::Size(3pm)

=back

=head1 BUGS AND LIMITATIONS

B<ekgping> parses the output of ping(1), which means it assumes a certain
output style. It will only work with ping(1) programs whose C<< ping -n >> output matches
"<digit> bytes from <ip>: icmp_req=<digit> ttl=<digit> time=<float>".

If a host is unreachable from the very beginning, B<ekgping> fails to start.

=head1 AUTHOR

Copyright (C) 2011 by Daniel Friesel E<lt>derf@finalrewind.orgE<gt>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
